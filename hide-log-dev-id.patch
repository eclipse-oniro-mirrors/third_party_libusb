diff --git a/libusb/os/linux_usbfs.c b/libusb/os/linux_usbfs.c
index 049d565..d819640 100644
--- a/libusb/os/linux_usbfs.c
+++ b/libusb/os/linux_usbfs.c
@@ -215,7 +215,7 @@ static int get_usbfs_fd(struct libusb_device *dev, int access_mode, int silent)
 	}
 
 	if (!silent) {
-		usbi_err(ctx, "libusb couldn't open USB device %s, errno=%d", path, errno);
+		usbi_err(ctx, "libusb couldn't open USB device, errno=%d", errno);
 		if (errno == EACCES && access_mode == O_RDWR)
 			usbi_err(ctx, "libusb requires write access to USB device nodes");
 	}
diff --git a/libusb/os/sunos_usb.c b/libusb/os/sunos_usb.c
index 761ca37..b8001da 100644
--- a/libusb/os/sunos_usb.c
+++ b/libusb/os/sunos_usb.c
@@ -173,7 +173,6 @@ sunos_usb_ioctl(struct libusb_device *dev, int cmd)
 	nvlist_add_int32(nvlist, "port", dev->port_number);
 	/* find the hub path */
 	snprintf(path_arg, sizeof(path_arg), "/devices%s:hubd", hubpath);
-	usbi_dbg(DEVICE_CTX(dev), "ioctl hub path: %s", path_arg);
 
 	fd = open(path_arg, O_RDONLY);
 	if (fd < 0) {
@@ -530,9 +529,9 @@ sunos_fill_in_dev_info(di_node_t node, struct libusb_device *dev)
 		dev->speed = LIBUSB_SPEED_SUPER;
 	}
 
-	usbi_dbg(DEVICE_CTX(dev), "vid=%x pid=%x, path=%s, bus_nmber=0x%x, port_number=%d, speed=%d",
+	usbi_dbg(DEVICE_CTX(dev), "vid=%x pid=%x, bus_nmber=0x%x, port_number=%d, speed=%d",
 	    dev->device_descriptor.idVendor, dev->device_descriptor.idProduct,
-	    dpriv->phypath, dev->bus_number, dev->port_number, dev->speed);
+	    dev->bus_number, dev->port_number, dev->speed);
 
 	return (LIBUSB_SUCCESS);
 }
@@ -592,7 +591,6 @@ sunos_add_devices(di_devlink_t link, void *arg)
 
 	/* dn is the usb device */
 	for (dn = di_child_node(myself); dn != DI_NODE_NIL; dn = di_sibling_node(dn)) {
-		usbi_dbg(NULL, "device path:%s", di_devfs_path(dn));
 		/* skip hub devices, because its driver can not been unload */
 		if (di_prop_lookup_ints(DDI_DEV_T_ANY, dn, "usb-port-count", &addr_prop) != -1)
 			continue;
@@ -1051,7 +1049,7 @@ sunos_get_active_config_descriptor(struct libusb_device *dev,
 	cfg = (struct libusb_config_descriptor *)dpriv->raw_cfgdescr;
 	len = MIN(len, libusb_le16_to_cpu(cfg->wTotalLength));
 	memcpy(buf, dpriv->raw_cfgdescr, len);
-	usbi_dbg(DEVICE_CTX(dev), "path:%s len %zu", dpriv->phypath, len);
+	usbi_dbg(DEVICE_CTX(dev), "len %zu", len);
 
 	return (len);
 }
diff --git a/libusb/os/windows_winusb.c b/libusb/os/windows_winusb.c
index c77bd20..e228e44 100644
--- a/libusb/os/windows_winusb.c
+++ b/libusb/os/windows_winusb.c
@@ -745,7 +745,7 @@ static void cache_config_descriptors(struct libusb_device *dev, HANDLE hub_handl
 
 	priv->config_descriptor = calloc(num_configurations, sizeof(PUSB_CONFIGURATION_DESCRIPTOR));
 	if (priv->config_descriptor == NULL) {
-		usbi_err(ctx, "could not allocate configuration descriptor array for '%s'", priv->dev_id);
+		usbi_err(ctx, "could not allocate configuration descriptor array");
 		return;
 	}
 
@@ -770,19 +770,19 @@ static void cache_config_descriptors(struct libusb_device *dev, HANDLE hub_handl
 		// coverity[tainted_data_argument]
 		if (!DeviceIoControl(hub_handle, IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION, &cd_buf_short, size,
 			&cd_buf_short, size, &ret_size, NULL)) {
-			usbi_info(ctx, "could not access configuration descriptor %u (dummy) for '%s': %s", i, priv->dev_id, windows_error_str(0));
+			usbi_info(ctx, "could not access configuration descriptor %u (dummy): %s", i, windows_error_str(0));
 			continue;
 		}
 
 		if ((ret_size != size) || (cd_buf_short.desc.wTotalLength < sizeof(USB_CONFIGURATION_DESCRIPTOR))) {
-			usbi_info(ctx, "unexpected configuration descriptor %u size (dummy) for '%s'", i, priv->dev_id);
+			usbi_info(ctx, "unexpected configuration descriptor %u size (dummy)", i);
 			continue;
 		}
 
 		size = sizeof(USB_DESCRIPTOR_REQUEST) + cd_buf_short.desc.wTotalLength;
 		cd_buf_actual = malloc(size);
 		if (cd_buf_actual == NULL) {
-			usbi_err(ctx, "could not allocate configuration descriptor %u buffer for '%s'", i, priv->dev_id);
+			usbi_err(ctx, "could not allocate configuration descriptor %u buffer for", i);
 			continue;
 		}
 
@@ -796,19 +796,19 @@ static void cache_config_descriptors(struct libusb_device *dev, HANDLE hub_handl
 
 		if (!DeviceIoControl(hub_handle, IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION, cd_buf_actual, size,
 			cd_buf_actual, size, &ret_size, NULL)) {
-			usbi_err(ctx, "could not access configuration descriptor %u (actual) for '%s': %s", i, priv->dev_id, windows_error_str(0));
+			usbi_err(ctx, "could not access configuration descriptor %u (actual): %s", i, windows_error_str(0));
 			continue;
 		}
 
 		cd_data = (PUSB_CONFIGURATION_DESCRIPTOR)((UCHAR *)cd_buf_actual + USB_DESCRIPTOR_REQUEST_SIZE);
 
 		if ((size != ret_size) || (cd_data->wTotalLength != cd_buf_short.desc.wTotalLength)) {
-			usbi_err(ctx, "unexpected configuration descriptor %u size (actual) for '%s'", i, priv->dev_id);
+			usbi_err(ctx, "unexpected configuration descriptor %u size (actual)", i);
 			continue;
 		}
 
 		if (cd_data->bDescriptorType != LIBUSB_DT_CONFIG) {
-			usbi_err(ctx, "descriptor %u not a configuration descriptor for '%s'", i, priv->dev_id);
+			usbi_err(ctx, "descriptor %u not a configuration descriptor", i);
 			continue;
 		}
 
@@ -918,18 +918,18 @@ static int init_root_hub(struct libusb_device *dev)
 	// changes if/how Windows returns any useful speed information.
 	handle = CreateFileA(priv->path, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
 	if (handle == INVALID_HANDLE_VALUE) {
-		usbi_err(ctx, "could not open root hub %s: %s", priv->path, windows_error_str(0));
+		usbi_err(ctx, "could not open root hub: %s", windows_error_str(0));
 		return LIBUSB_ERROR_ACCESS;
 	}
 
 	if (!DeviceIoControl(handle, IOCTL_USB_GET_NODE_INFORMATION, NULL, 0, &hub_info, sizeof(hub_info), &size, NULL)) {
-		usbi_warn(ctx, "could not get root hub info for '%s': %s", priv->dev_id, windows_error_str(0));
+		usbi_warn(ctx, "could not get root hub info: %s", windows_error_str(0));
 		CloseHandle(handle);
 		return LIBUSB_ERROR_ACCESS;
 	}
 
 	num_ports = hub_info.u.HubInformation.HubDescriptor.bNumberOfPorts;
-	usbi_dbg(ctx, "root hub '%s' reports %lu ports", priv->dev_id, ULONG_CAST(num_ports));
+	usbi_dbg(ctx, "root hub reports %lu ports", ULONG_CAST(num_ports));
 
 	if (windows_version >= WINDOWS_8) {
 		// Windows 8 and later is better at reporting the speed capabilities of the root hub,
@@ -942,8 +942,8 @@ static int init_root_hub(struct libusb_device *dev)
 			conn_info_v2.SupportedUsbProtocols.Usb300 = 1;
 			if (!DeviceIoControl(handle, IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX_V2,
 				&conn_info_v2, sizeof(conn_info_v2), &conn_info_v2, sizeof(conn_info_v2), &size, NULL)) {
-				usbi_warn(ctx, "could not get node connection information (V2) for root hub '%s' port %lu: %s",
-					priv->dev_id, ULONG_CAST(port_number), windows_error_str(0));
+				usbi_warn(ctx, "could not get node connection information (V2) for root hub port %lu: %s",
+					ULONG_CAST(port_number), windows_error_str(0));
 				break;
 			}
 
@@ -982,8 +982,8 @@ static int init_root_hub(struct libusb_device *dev)
 		conn_info.ConnectionIndex = port_number;
 		if (!DeviceIoControl(handle, IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX, &conn_info, sizeof(conn_info),
 			&conn_info, sizeof(conn_info), &size, NULL)) {
-			usbi_warn(ctx, "could not get node connection information for root hub '%s' port %lu: %s",
-				priv->dev_id, ULONG_CAST(port_number), windows_error_str(0));
+			usbi_warn(ctx, "could not get node connection information for root hub port %lu: %s",
+				ULONG_CAST(port_number), windows_error_str(0));
 			continue;
 		}
 
@@ -1053,7 +1053,7 @@ make_descriptors:
 
 	r = alloc_root_hub_config_desc(dev, num_ports, config_desc_length, ep_interval);
 	if (r)
-		usbi_err(ctx, "could not allocate config descriptor for root hub '%s'", priv->dev_id);
+		usbi_err(ctx, "could not allocate config descriptor");
 
 	return r;
 }
@@ -1084,7 +1084,7 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 		ctx = DEVICE_CTX(dev);
 		parent_priv = usbi_get_device_priv(parent_dev);
 		if (parent_priv->apib->id != USB_API_HUB) {
-			usbi_warn(ctx, "parent for device '%s' is not a hub", priv->dev_id);
+			usbi_warn(ctx, "parent is not a hub");
 			return LIBUSB_ERROR_NOT_FOUND;
 		}
 
@@ -1101,7 +1101,7 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 			for (depth = 1; bus_number == 0; depth++) {
 				tmp_dev = get_ancestor(ctx, devinst, &devinst);
 				if (tmp_dev == NULL) {
-					usbi_warn(ctx, "ancestor for device '%s' not found at depth %u", priv->dev_id, depth);
+					usbi_warn(ctx, "ancestor not found at depth %u", depth);
 					return LIBUSB_ERROR_NO_DEVICE;
 				}
 				if (tmp_dev->bus_number != 0) {
@@ -1116,7 +1116,7 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 		}
 
 		if (bus_number == 0) {
-			usbi_err(ctx, "program assertion failed - bus number not found for '%s'", priv->dev_id);
+			usbi_err(ctx, "program assertion failed - bus number not found");
 			return LIBUSB_ERROR_NOT_FOUND;
 		}
 
@@ -1127,7 +1127,7 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 
 		hub_handle = CreateFileA(parent_priv->path, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
 		if (hub_handle == INVALID_HANDLE_VALUE) {
-			usbi_warn(ctx, "could not open hub %s: %s", parent_priv->path, windows_error_str(0));
+			usbi_warn(ctx, "could not open hub: %s", windows_error_str(0));
 			return LIBUSB_ERROR_ACCESS;
 		}
 
@@ -1136,21 +1136,21 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 
 		if (!DeviceIoControl(hub_handle, IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX, &conn_info, sizeof(conn_info),
 			&conn_info, sizeof(conn_info), &size, NULL)) {
-			usbi_warn(ctx, "could not get node connection information for device '%s': %s",
-				priv->dev_id, windows_error_str(0));
+			usbi_warn(ctx, "could not get node connection information': %s",
+				windows_error_str(0));
 			CloseHandle(hub_handle);
 			return LIBUSB_ERROR_NO_DEVICE;
 		}
 
 		if (conn_info.ConnectionStatus == NoDeviceConnected) {
-			usbi_err(ctx, "device '%s' is no longer connected!", priv->dev_id);
+			usbi_err(ctx, "device is no longer connected!");
 			CloseHandle(hub_handle);
 			return LIBUSB_ERROR_NO_DEVICE;
 		}
 
 		if ((conn_info.DeviceDescriptor.bLength != LIBUSB_DT_DEVICE_SIZE)
 			|| (conn_info.DeviceDescriptor.bDescriptorType != LIBUSB_DT_DEVICE)) {
-			usbi_err(ctx, "device '%s' has invalid descriptor!", priv->dev_id);
+			usbi_err(ctx, "device has invalid descriptor!");
 			CloseHandle(hub_handle);
 			return LIBUSB_ERROR_OTHER;
 		}
@@ -1161,16 +1161,15 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 		usbi_localize_device_descriptor(&dev->device_descriptor);
 
 		if (conn_info.CurrentConfigurationValue == 0) {
-			usbi_dbg(ctx, "found %u configurations for device '%s' but device is not configured (i.e. current config: 0), ignoring it",
-				dev->device_descriptor.bNumConfigurations,
-				priv->dev_id);
+			usbi_dbg(ctx, "found %u configurations but device is not configured (i.e. current config: 0), ignoring it",
+				dev->device_descriptor.bNumConfigurations);
 			CloseHandle(hub_handle);
 			return LIBUSB_ERROR_OTHER;
 		}
 
 		priv->active_config = conn_info.CurrentConfigurationValue;
-		usbi_dbg(ctx, "found %u configurations (current config: %u) for device '%s'",
-			dev->device_descriptor.bNumConfigurations, priv->active_config,	priv->dev_id);
+		usbi_dbg(ctx, "found %u configurations (current config: %u)",
+			dev->device_descriptor.bNumConfigurations, priv->active_config);
 
 		// Cache as many config descriptors as we can
 		cache_config_descriptors(dev, hub_handle);
@@ -1182,8 +1181,8 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 			conn_info_v2.SupportedUsbProtocols.Usb300 = 1;
 			if (!DeviceIoControl(hub_handle, IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX_V2,
 				&conn_info_v2, sizeof(conn_info_v2), &conn_info_v2, sizeof(conn_info_v2), &size, NULL)) {
-				usbi_warn(ctx, "could not get node connection information (V2) for device '%s': %s",
-					priv->dev_id,  windows_error_str(0));
+				usbi_warn(ctx, "could not get node connection information (V2): %s",
+					windows_error_str(0));
 			} else if (conn_info_v2.Flags.DeviceIsOperatingAtSuperSpeedPlusOrHigher) {
 				conn_info.Speed = UsbSuperSpeedPlus;
 			} else if (conn_info_v2.Flags.DeviceIsOperatingAtSuperSpeedOrHigher) {
@@ -1220,8 +1219,8 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 
 	priv->initialized = true;
 
-	usbi_dbg(ctx, "(bus: %u, addr: %u, depth: %u, port: %u): '%s'",
-		dev->bus_number, dev->device_address, priv->depth, dev->port_number, priv->dev_id);
+	usbi_dbg(ctx, "(bus: %u, addr: %u, depth: %u, port: %u)",
+		dev->bus_number, dev->device_address, priv->depth, dev->port_number);
 
 	return LIBUSB_SUCCESS;
 }
@@ -1290,18 +1289,18 @@ static int enumerate_hcd_root_hub(struct libusb_context *ctx, const char *dev_id
 	struct libusb_device* dev;
 
 	if (CM_Get_Child(&child_devinst, devinst, 0) != CR_SUCCESS) {
-		usbi_warn(ctx, "could not get child devinst for '%s'", dev_id);
+		usbi_warn(ctx, "could not get child devinst");
 		return LIBUSB_SUCCESS;
 	}
 
 	dev = usbi_get_device_by_session_id(ctx, (unsigned long)child_devinst);
 	if (dev == NULL) {
-		usbi_warn(ctx, "HCD '%s' child not found", dev_id);
+		usbi_warn(ctx, "HCD child not found");
 		return LIBUSB_SUCCESS;
 	}
 
 	if (sscanf(dev_id, "PCI\\VEN_%04hx&DEV_%04hx%*s", &dev->device_descriptor.idVendor, &dev->device_descriptor.idProduct) != 2)
-			usbi_warn(ctx, "could not infer VID/PID of HCD from '%s'", dev_id);
+			usbi_warn(ctx, "could not infer VID/PID of HCD");
 	libusb_unref_device(dev);
 	return LIBUSB_SUCCESS;
 }
@@ -1388,7 +1387,7 @@ static int set_composite_interface(struct libusb_context *ctx, struct libusb_dev
 	}
 
 	if (interface_number >= USB_MAXINTERFACES) {
-		usbi_warn(ctx, "interface %d too large - ignoring interface path %s", interface_number, dev_interface_path);
+		usbi_warn(ctx, "interface %d too large - ignoring interface path", interface_number);
 		return LIBUSB_ERROR_ACCESS;
 	}
 
@@ -1403,7 +1402,6 @@ static int set_composite_interface(struct libusb_context *ctx, struct libusb_dev
 		safe_free(priv->usb_interface[interface_number].path);
 	}
 
-	usbi_dbg(ctx, "interface[%d] = %s", interface_number, dev_interface_path);
 	priv->usb_interface[interface_number].path = dev_interface_path;
 	priv->usb_interface[interface_number].apib = &usb_api_backend[api];
 	priv->usb_interface[interface_number].sub_api = sub_api;
@@ -1453,7 +1451,7 @@ static int set_hid_interface(struct libusb_context *ctx, struct libusb_device *d
 
 	for (i = 0; i < priv->hid->nb_interfaces; i++) {
 		if ((priv->usb_interface[i].path != NULL) && strcmp(priv->usb_interface[i].path, dev_interface_path) == 0) {
-			usbi_dbg(ctx, "interface[%u] already set to %s", i, dev_interface_path);
+			usbi_dbg(ctx, "interface[%u] already set", i);
 			return LIBUSB_ERROR_ACCESS;
 		}
 	}
@@ -1482,7 +1480,7 @@ static int get_guid(struct libusb_context *ctx, char *dev_id, HDEVINFO *dev_info
 
 	key = pSetupDiOpenDevRegKey(*dev_info, dev_info_data, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ);
 	if (key == INVALID_HANDLE_VALUE) {
-		usbi_warn(ctx, "Cannot get the additional GUIDs for '%s'", dev_id);
+		usbi_warn(ctx, "Cannot get the additional GUIDs");
 		return LIBUSB_ERROR_ACCESS;
 	}
 	// Reserve buffer large enough to hold one GUID with two terminating characters
@@ -1509,13 +1507,13 @@ static int get_guid(struct libusb_context *ctx, char *dev_id, HDEVINFO *dev_info
 			// The GUID was read successfully
 			break;
 		} else if (s == ERROR_FILE_NOT_FOUND) {
-			usbi_dbg(ctx, "no DeviceInterfaceGUID registered for '%s'", dev_id);
+			usbi_dbg(ctx, "no DeviceInterfaceGUID registered");
 			err = LIBUSB_ERROR_ACCESS;
 			goto exit;
 		} else if (s == ERROR_MORE_DATA) {
 			if (pass == 1) {
 				// Previous pass should have allocated enough memory, but reading failed
-				usbi_warn(ctx, "unexpected error from pRegQueryValueExA for '%s'", dev_id);
+				usbi_warn(ctx, "unexpected error from pRegQueryValueExA");
 				err = LIBUSB_ERROR_OTHER;
 				goto exit;
 			}
@@ -1527,7 +1525,7 @@ static int get_guid(struct libusb_context *ctx, char *dev_id, HDEVINFO *dev_info
 			}
 			guid_string = new_guid_string;
 		} else {
-			usbi_warn(ctx, "unexpected error from pRegQueryValueExA for '%s'", dev_id);
+			usbi_warn(ctx, "unexpected error from pRegQueryValueExA");
 			err = LIBUSB_ERROR_ACCESS;
 			goto exit;
 		}
@@ -1552,7 +1550,7 @@ static int get_guid(struct libusb_context *ctx, char *dev_id, HDEVINFO *dev_info
 		while (guids_left) {
 			guid = strchr(guid, '}');
 			if (guid == NULL) {
-				usbi_warn(ctx, "no GUID with index %d registered for '%s'", guid_number, dev_id);
+				usbi_warn(ctx, "no GUID with index %d registered", guid_number);
 				err = LIBUSB_ERROR_ACCESS;
 				goto exit;
 			}
@@ -1566,7 +1564,7 @@ static int get_guid(struct libusb_context *ctx, char *dev_id, HDEVINFO *dev_info
 		// Add terminating char to the string
 		guid_term = strchr(guid, '}');
 		if (guid_term == NULL) {
-			usbi_warn(ctx, "no GUID with index %d registered for '%s'", guid_number, dev_id);
+			usbi_warn(ctx, "no GUID with index %d registered", guid_number);
 			err = LIBUSB_ERROR_ACCESS;
 			goto exit;
 		}
@@ -1574,7 +1572,7 @@ static int get_guid(struct libusb_context *ctx, char *dev_id, HDEVINFO *dev_info
 		guid_term++;
 		*guid_term = '\0';
 	} else {
-		usbi_warn(ctx, "unexpected type of DeviceInterfaceGUID for '%s'", dev_id);
+		usbi_warn(ctx, "unexpected type of DeviceInterfaceGUID");
 		err = LIBUSB_ERROR_ACCESS;
 		goto exit;
 	}
@@ -1586,7 +1584,7 @@ static int get_guid(struct libusb_context *ctx, char *dev_id, HDEVINFO *dev_info
 		goto exit;
 	}
 	if (!string_to_guid(guid, *if_guid)) {
-		usbi_warn(ctx, "device '%s' has malformed DeviceInterfaceGUID string '%s', skipping", dev_id, guid);
+		usbi_warn(ctx, "device has malformed DeviceInterfaceGUID string '%s', skipping", guid);
 		free(*if_guid);
 		*if_guid = NULL;
 		goto exit;
@@ -1738,7 +1736,7 @@ static int winusb_get_device_list(struct libusb_context *ctx, struct discovered_
 				continue;
 			}
 
-			usbi_dbg(ctx, "ENUM processing %s", dev_id);
+			usbi_dbg(ctx, "ENUM processing");
 
 			// Set API to use or get additional data from generic pass
 			api = USB_API_UNSUPPORTED;
@@ -1752,7 +1750,7 @@ static int winusb_get_device_list(struct libusb_context *ctx, struct discovered_
 				// This will allow us to enumerate all classes during the GEN pass
 				if (!pSetupDiGetDeviceRegistryPropertyA(*dev_info, &dev_info_data, SPDRP_ENUMERATOR_NAME,
 					NULL, (PBYTE)enumerator, sizeof(enumerator), NULL)) {
-					usbi_err(ctx, "could not read enumerator string for device '%s': %s", dev_id, windows_error_str(0));
+					usbi_err(ctx, "could not read enumerator string for device: %s", windows_error_str(0));
 					LOOP_BREAK(LIBUSB_ERROR_OTHER);
 				}
 				for (j = 0; j < nb_usb_enumerators; j++) {
@@ -1778,7 +1776,7 @@ static int winusb_get_device_list(struct libusb_context *ctx, struct discovered_
 				// We use the GEN pass to detect driverless devices...
 				if (!pSetupDiGetDeviceRegistryPropertyA(*dev_info, &dev_info_data, SPDRP_DRIVER,
 					NULL, NULL, 0, NULL) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
-					usbi_info(ctx, "The following device has no driver: '%s'", dev_id);
+					usbi_info(ctx, "The following device has no driver");
 					usbi_info(ctx, "libusb will not be able to access it");
 				}
 				// ...and to add the additional device interface GUIDs
@@ -1813,7 +1811,7 @@ static int winusb_get_device_list(struct libusb_context *ctx, struct discovered_
 					LOOP_BREAK(LIBUSB_ERROR_NO_MEM);
 				} else {
 					if (r != LIBUSB_SUCCESS) {
-						usbi_warn(ctx, "unexpected error during getting DeviceInterfaceGUID for '%s'", dev_id);
+						usbi_warn(ctx, "unexpected error during getting DeviceInterfaceGUID");
 					}
 				}
 				break;
@@ -1825,11 +1823,11 @@ static int winusb_get_device_list(struct libusb_context *ctx, struct discovered_
 				// Get the API type (after checking that the driver installation is OK)
 				if ((!pSetupDiGetDeviceRegistryPropertyA(*dev_info, &dev_info_data, SPDRP_INSTALL_STATE,
 					NULL, (PBYTE)&install_state, sizeof(install_state), &size)) || (size != sizeof(install_state))) {
-					usbi_warn(ctx, "could not detect installation state of driver for '%s': %s",
-						dev_id, windows_error_str(0));
+					usbi_warn(ctx, "could not detect installation state of driver: %s",
+						windows_error_str(0));
 				} else if (install_state != 0) {
-					usbi_warn(ctx, "driver for device '%s' is reporting an issue (code: %lu) - skipping",
-						dev_id, ULONG_CAST(install_state));
+					usbi_warn(ctx, "driver for device is reporting an issue (code: %lu) - skipping",
+						ULONG_CAST(install_state));
 					continue;
 				}
 				get_api_type(dev_info, &dev_info_data, &api, &sub_api);
@@ -1851,7 +1849,7 @@ static int winusb_get_device_list(struct libusb_context *ctx, struct discovered_
 						libusb_unref_device(dev);
 					}
 
-					usbi_dbg(ctx, "unlisted ancestor for '%s' (non USB HID, newly connected, etc.) - ignoring", dev_id);
+					usbi_dbg(ctx, "unlisted ancestor (non USB HID, newly connected, etc.) - ignoring");
 					continue;
 				}
 
@@ -1939,7 +1937,7 @@ static int winusb_get_device_list(struct libusb_context *ctx, struct discovered_
 							}
 							priv->root_hub = true;
 							dev->bus_number = ++bus_number;
-							usbi_dbg(ctx, "assigning Root Hub '%s' bus number %u", dev_id, bus_number);
+							usbi_dbg(ctx, "assigning Root Hub bus number %u", bus_number);
 						}
 					} else {
 						libusb_unref_device(parent_dev);
@@ -1968,7 +1966,7 @@ static int winusb_get_device_list(struct libusb_context *ctx, struct discovered_
 			case GEN_PASS:
 				port_nr = 0;
 				if (!get_dev_port_number(*dev_info, &dev_info_data, &port_nr))
-					usbi_warn(ctx, "could not retrieve port number for device '%s': %s", dev_id, windows_error_str(0));
+					usbi_warn(ctx, "could not retrieve port number: %s", windows_error_str(0));
 				r = init_device(dev, parent_dev, (uint8_t)port_nr, dev_info_data.DevInst);
 				if (r == LIBUSB_SUCCESS) {
 					// Append device to the list of discovered devices
@@ -1980,7 +1978,7 @@ static int winusb_get_device_list(struct libusb_context *ctx, struct discovered_
 				} else {
 					// Failed to initialize a single device doesn't stop us from enumerating all other devices,
 					// but we skip it (don't add to list of discovered devices)
-					usbi_warn(ctx, "failed to initialize device '%s'", priv->dev_id);
+					usbi_warn(ctx, "failed to initialize device");
 					r = LIBUSB_SUCCESS;
 				}
 				break;
@@ -2609,7 +2607,7 @@ static int winusbx_open(int sub_api, struct libusb_device_handle *dev_handle)
 				&& (priv->usb_interface[i].apib->id == USB_API_WINUSBX)) {
 			file_handle = windows_open(dev_handle, priv->usb_interface[i].path, GENERIC_READ | GENERIC_WRITE);
 			if (file_handle == INVALID_HANDLE_VALUE) {
-				usbi_err(HANDLE_CTX(dev_handle), "could not open device %s (interface %d): %s", priv->usb_interface[i].path, i, windows_error_str(0));
+				usbi_err(HANDLE_CTX(dev_handle), "could not open device (interface %d): %s", i, windows_error_str(0));
 				switch (GetLastError()) {
 				case ERROR_FILE_NOT_FOUND: // The device was disconnected
 					return LIBUSB_ERROR_NO_DEVICE;
@@ -4004,7 +4002,7 @@ static int hid_open(int sub_api, struct libusb_device_handle *dev_handle)
 				usbi_warn(HANDLE_CTX(dev_handle), "could not open HID device in R/W mode (keyboard or mouse?) - trying without");
 				hid_handle = windows_open(dev_handle, priv->usb_interface[i].path, 0);
 				if (hid_handle == INVALID_HANDLE_VALUE) {
-					usbi_err(HANDLE_CTX(dev_handle), "could not open device %s (interface %d): %s", priv->path, i, windows_error_str(0));
+					usbi_err(HANDLE_CTX(dev_handle), "could not open device (interface %d): %s", i, windows_error_str(0));
 					switch (GetLastError()) {
 					case ERROR_FILE_NOT_FOUND: // The device was disconnected
 						return LIBUSB_ERROR_NO_DEVICE;
